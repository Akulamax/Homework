#include <iostream>
#include <cmath>
using namespace std;
//! Возвращает true, если n четное
template <class T>
bool even (const T & n)
{
	return (n % 2) == 0;
}
unsigned gcd(unsigned u, unsigned v) {
    while ( v != 0) {
        unsigned r = u % v;
        u = v;
        v = r;
    }
    return u;
}

//! Умножает a *= b (mod n)
template <class T>
void mulmod (T & a, T b, const T & n)
{
	// наивная версия, годится только для длинной арифметики
	a *= b;
	a %= n;
}
//! Вычисляет a^k (mod n). Использует бинарное возведение в степень
template <class T, class T2>
T powmod (T a, T2 k, const T & n)
{
	T res = 1;
	while (k)
		if (!even (k))
		{
			mulmod (res, a, n);
			--k;
		}
		else
		{
			mulmod (a, a, n);
			k/=2;
		}
	return res;
}

//! Переводит число n в форму q*2^p
template <class T>
void transform_num (T n, T & p, T & q)
{
	T p_res = 0;
	while (even (n))
	{
		++p_res;
		n/=2;
	}
	p = p_res;
	q = n;
}
template <class T, class T2>
bool miller_rabin (T n, T2 b)
{

	// сначала проверяем тривиальные случаи
	if (n == 2)
		return true;
	if (n < 2 || even (n))
		return false;

	// проверяем, что n и b взаимно просты (иначе это приведет к ошибке)
	// если они не взаимно просты, то либо n не просто, либо нужно увеличить b
	if (b < 2)
		b = 2;
	for (T g; (g = gcd (n, b)) != 1; ++b)
		if (n > g)
			return false;

	// разлагаем n-1 = q*2^p
	T n_1 = n;
	--n_1;
	T p, q;
	transform_num (n_1, p, q);

	// вычисляем b^q mod n, если оно равно 1 или n-1, то n простое (или псевдопростое)
	T rem = powmod (T(b), q, n);
	if (rem == 1 || rem == n_1)
		return true;

	// теперь вычисляем b^2q, b^4q, ... , b^((n-1)/2)
	// если какое-либо из них равно n-1, то n простое (или псевдопростое)
	for (T i=1; i<p; i++)
	{
		mulmod (rem, rem, n);
		if (rem == n_1)
			return true;
	}

	return false;

}
int main()
{int a,b=2;
cin>>a;
/*for (b=1;b<a;b++){
cout<<miller_rabin (a, b);
if (miller_rabin (a, b)==0){
    c=c+1;}
if (miller_rabin (a, b)==1){
    k=k+1;}}

cout<<"               "<<c<<"/"<<k;*/
cout<<miller_rabin (a, b);
    return 0;
}
